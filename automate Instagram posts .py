# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_FmIoStTyXT5SpCfUvLvb7HnOe5zEMum
"""

.

# Step 1: Install Required Libraries
!pip install nest_asyncio python-telegram-bot==20.3 instagrapi stability-sdk python-dotenv pillow requests google-generativeai

# Step 2: Import Libraries
import os
import time
import threading
import tempfile
import requests
import random
import google.generativeai as genai
from telegram import Update
from telegram.ext import Application, MessageHandler, filters, ContextTypes
from instagrapi import Client
from instagrapi.exceptions import LoginRequired, ChallengeRequired
from stability_sdk import client
import stability_sdk.interfaces.gooseai.generation.generation_pb2 as generation
from PIL import Image
from io import BytesIO
import nest_asyncio

# Apply nest_asyncio to fix event loop issues
nest_asyncio.apply()

# Step 3: Configuration (Replace with your actual credentials)
TELEGRAM_TOKEN = "xxxxx"
GEMINI_API_KEY = "xxxxx"  # Get from https://aistudio.google.com/app/apikey
STABILITY_API_KEY = "xxxxx"
INSTAGRAM_USERNAME = "xxxxx"
INSTAGRAM_PASSWORD = "xxxxxxx"
ALLOWED_USER_ID = "xxxxxxxx"

# Security and Rate Limiting
MIN_POST_INTERVAL = 10  # 10 minutes between posts
last_post_time = 0
lock = threading.Lock()

# Step 4: Core Functions
def generate_image(prompt: str) -> str:
    """Generate image using Stability AI"""
    try:
        # Initialize Stability client
        stability_api = client.StabilityInference(
            key=STABILITY_API_KEY,
            verbose=True,  # Show debug logs
            engine="stable-diffusion-xl-1024-v1-0"
        )

        # Generate the image
        answers = stability_api.generate(
            prompt=prompt,
            seed=random.randint(1000, 9999),  # Random seed for variation
            steps=30,
            cfg_scale=8.0,
            width=1024,
            height=1024,
            samples=1
        )

        # Process the response
        for resp in answers:
            for artifact in resp.artifacts:
                if artifact.type == generation.ARTIFACT_IMAGE:
                    img = Image.open(BytesIO(artifact.binary))
                    temp_file = tempfile.NamedTemporaryFile(suffix=".jpg", delete=False)
                    img.save(temp_file.name, format='JPEG')
                    return temp_file.name

        raise Exception("No image artifacts found in response")
    except Exception as e:
        raise Exception(f"Image generation failed: {str(e)}")

def generate_caption(prompt: str) -> str:
    """Generate Instagram caption with hashtags using Gemini"""
    try:
        # Configure Gemini with updated API version
        genai.configure(api_key=GEMINI_API_KEY)

        # Use the correct model name for text generation
        model = genai.GenerativeModel('gemini-2.0-flash')

        # Create prompt with instructions
        full_prompt = (
            "You are an Instagram content creator. Generate: "
            "1. An engaging caption (1-2 sentences) "
            "2. A line break (using '\n\n') "
            "3. 10 relevant hashtags starting with '#' "
            f"for a post about: {prompt}"
        )

        # Generate content with safety settings
        response = model.generate_content(
            full_prompt,
            generation_config=genai.types.GenerationConfig(
                temperature=0.7,
                max_output_tokens=300
            ),
            safety_settings={
                'HARASSMENT': 'block_none',
                'HATE_SPEECH': 'block_none',
                'SEXUAL': 'block_none',
                'DANGEROUS': 'block_none'
            }
        )

        # Handle potential errors in response
        if not response.text:
            if response.prompt_feedback:
                raise Exception(f"Prompt blocked: {response.prompt_feedback}")
            else:
                raise Exception("Empty response from Gemini")

        return response.text.strip()
    except Exception as e:
        raise Exception(f"Caption generation failed: {str(e)}")

def post_to_instagram(image_path: str, caption: str) -> bool:
    """Post to Instagram using session cookies"""
    try:
        cl = Client()
        session_file = "instagram_session.json"

        # Try to load existing session
        if os.path.exists(session_file):
            try:
                cl.load_settings(session_file)
                # Test session with a safe API call
                cl.get_timeline_feed()
                print("Logged in via session cookies")
            except (LoginRequired, ChallengeRequired) as e:
                print(f"Session expired: {str(e)} - Re-logging in")
                # Perform login with device-specific settings
                cl.login(INSTAGRAM_USERNAME, INSTAGRAM_PASSWORD)
                cl.dump_settings(session_file)
            except Exception as e:
                print(f"Session test failed: {str(e)} - Re-logging in")
                cl.login(INSTAGRAM_USERNAME, INSTAGRAM_PASSWORD)
                cl.dump_settings(session_file)
        else:
            # New login with device simulation
            print("No session found - Performing new login")
            cl.login(INSTAGRAM_USERNAME, INSTAGRAM_PASSWORD)
            cl.dump_settings(session_file)

        # Upload post with retry logic
        for attempt in range(3):
            try:
                print(f"Uploading post (attempt {attempt+1})")
                result = cl.photo_upload(image_path, caption)
                if result:
                    print("Post uploaded successfully")
                    return True
            except (LoginRequired, ChallengeRequired) as e:
                print(f"Upload failed (attempt {attempt+1}): {str(e)}")
                # Re-login and retry
                cl.login(INSTAGRAM_USERNAME, INSTAGRAM_PASSWORD)
                cl.dump_settings(session_file)
            except Exception as e:
                print(f"Upload error (attempt {attempt+1}): {str(e)}")
                time.sleep(5)  # Wait before retrying

        print("All upload attempts failed")
        return False
    except Exception as e:
        print(f"Instagram error: {str(e)}")
        return False

# Step 5: Telegram Bot Handler
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global last_post_time

    # Verify user
    if str(update.message.from_user.id) != ALLOWED_USER_ID:
        await update.message.reply_text("â›” Unauthorized access denied")
        return

    # Rate limiting
    current_time = time.time()
    if current_time - last_post_time < MIN_POST_INTERVAL:
        wait_time = int(MIN_POST_INTERVAL - (current_time - last_post_time))
        await update.message.reply_text(f"âŒ› Please wait {wait_time} seconds before next request")
        return

    prompt = update.message.text
    await update.message.reply_text("ðŸ”„ Processing your request...")

    image_path = None
    try:
        # Generate content
        await update.message.reply_text("ðŸŽ¨ Generating image...")
        image_path = generate_image(prompt)

        await update.message.reply_text("ðŸ“ Creating caption...")
        caption = generate_caption(prompt)

        # Preview before posting
        await update.message.reply_photo(photo=open(image_path, 'rb'))
        await update.message.reply_text(f"ðŸ“ Caption Preview:\n\n{caption}\n\nPosting to Instagram...")

        # Post to Instagram
        if post_to_instagram(image_path, caption):
            with lock:
                last_post_time = time.time()
            await update.message.reply_text("âœ… Post successful!")
        else:
            await update.message.reply_text("âŒ Instagram posting failed. Please try again later.")

    except Exception as e:
        error_msg = f"âš ï¸ Error: {str(e)}"
        print(error_msg)
        await update.message.reply_text(error_msg)
    finally:
        # Cleanup image file
        if image_path and os.path.exists(image_path):
            os.unlink(image_path)

# Step 6: Main Execution
def main():
    # Start Telegram bot
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    print("Bot is running...")
    print(f"Send prompts to your bot. Waiting for user: {ALLOWED_USER_ID}")
    print("Note: Keep this Colab tab open for continuous operation")
    application.run_polling()

if __name__ == "__main__":
    main()