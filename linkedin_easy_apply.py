# -*- coding: utf-8 -*-
"""LinkedIn Easy Apply.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_FmIoStTyXT5SpCfUvLvb7HnOe5zEMum
"""

#Important
import os
import re
import time
import json
import pdfplumber
import threading
import queue
import gspread
import google.generativeai as genai
import asyncio
import tempfile
import shutil
from telegram import Update, Bot
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    ConversationHandler
)
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from google.oauth2.service_account import Credentials

# ===== Configuration =====
TELEGRAM_TOKEN = "xxxxxxxxxxx"
GEMINI_API_KEY = "xxxxxxxx"
LINKEDIN_EMAIL = "xxxxxxx"
LINKEDIN_PASSWORD = "xxxxx"
ALLOWED_USER_ID = "xxxxxx"

# Google Sheets configuration
GOOGLE_SHEETS_CREDS = {
    "type": "service_account",
    # Add your full service account JSON credentials here
    "project_id": "your-project-id",
    "private_key_id": "your-private-key-id",
    "private_key": "-----BEGIN PRIVATE KEY-----\nYOUR_PRIVATE_KEY\n-----END PRIVATE KEY-----\n",
    "client_email": "your-service-account-email@project-id.iam.gserviceaccount.com",
    "client_id": "your-client-id",
    "auth_uri": "https://accounts.google.com/o/oauth2/auth",
    "token_uri": "https://oauth2.googleapis.com/token",
    "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
    "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/your-service-account-email%40project-id.iam.gserviceaccount.com"
}
SPREADSHEET_ID = "your-spreadsheet-id"

# Rule-based dataset
RULE_BASED_DATA = {
    "location": "Kapu, Karnataka, Udupi",
    "expected_ctc": "450000",
    "previous_salary": "192000",
    "experience": "2.5",
    "notice_period": "30",
    "phone": "7022606331",
    "name": "Mohammed Nihal"
}

# States for conversation handler
JOB_ROLE, NUM_APPLICATIONS, LOCATION, RESUME = range(4)
application_data_queue = queue.Queue()

# ===== Helper Functions =====
def parse_resume(file_path):
    """Extract text from PDF resume"""
    text = ""
    with pdfplumber.open(file_path) as pdf:
        for page in pdf.pages:
            page_text = page.extract_text()
            if page_text:
                text += page_text + "\n"
    return text

def log_to_google_sheets(data):
    """Log application data to Google Sheets"""
    # Create credentials from dictionary
    creds = Credentials.from_service_account_info(
        GOOGLE_SHEETS_CREDS,
        scopes=['https://www.googleapis.com/auth/spreadsheets']
    )

    client = gspread.authorize(creds)
    sheet = client.open_by_key(SPREADSHEET_ID).sheet1

    sheet.append_row([
        data['date'],
        data['start_time'],
        data['job_role'],
        data['company'],
        data['questions_asked'],
        data['questions_answered'],
        data['submit_time'],
        data['duration']
    ])

# ===== Telegram Bot Functions =====
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    # Check if user is authorized
    if str(update.message.from_user.id) != ALLOWED_USER_ID:
        await update.message.reply_text("⛔ You are not authorized to use this bot.")
        return ConversationHandler.END

    await update.message.reply_text("Hi, what kind of job role are you looking for?")
    return JOB_ROLE

async def job_role(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['job_role'] = update.message.text
    await update.message.reply_text(
        f"Great! How many job applications should I submit for {update.message.text}?"
    )
    return NUM_APPLICATIONS

async def num_applications(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        num = int(update.message.text)
        if num <= 0:
            await update.message.reply_text("Please enter a positive number.")
            return NUM_APPLICATIONS
        context.user_data['num_applications'] = num
        await update.message.reply_text("Which location?")
        return LOCATION
    except ValueError:
        await update.message.reply_text("Please enter a valid number.")
        return NUM_APPLICATIONS

async def location(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['location'] = update.message.text
    await update.message.reply_text("Upload your resume in PDF format.")
    return RESUME

async def resume(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    file = await update.message.document.get_file()
    temp_file = f"resume_{update.message.chat_id}.pdf"
    await file.download_to_drive(temp_file)

    context.user_data['resume_path'] = temp_file
    context.user_data['chat_id'] = update.message.chat_id

    application_data_queue.put(dict(context.user_data))

    await update.message.reply_text(
        "Got your resume! Starting job applications..."
    )
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text('Operation cancelled.')
    return ConversationHandler.END

# ===== LinkedIn Automation =====
class LinkedInAutomator:
    def __init__(self):
        chrome_options = webdriver.ChromeOptions()
        chrome_options.add_argument("--disable-blink-features=AutomationControlled")

        # Create a unique temporary directory for each browser session
        self.user_data_dir = tempfile.mkdtemp()
        chrome_options.add_argument(f"--user-data-dir={self.user_data_dir}")

        self.driver = webdriver.Chrome(options=chrome_options)
        self.driver.maximize_window()
        self.wait = WebDriverWait(self.driver, 20)
        self.resume_text = ""
        self.qa_pairs = []

    def login(self):
        self.driver.get("https://www.linkedin.com/login")
        email = self.wait.until(EC.presence_of_element_located((By.ID, "username")))
        email.send_keys(LINKEDIN_EMAIL)
        password = self.driver.find_element(By.ID, "password")
        password.send_keys(LINKEDIN_PASSWORD)
        password.submit()
        self.wait.until(EC.presence_of_element_located((By.ID, "global-nav")))

    def search_jobs(self, job_role, location):
        self.driver.get("https://www.linkedin.com/jobs")
        search_input = self.wait.until(EC.element_to_be_clickable(
            (By.CSS_SELECTOR, "input[aria-label='Search by title, skill, or company']")
        ))
        search_input.send_keys(job_role)

        location_input = self.driver.find_element(
            By.CSS_SELECTOR, "input[aria-label='City, state, or zip code']")
        location_input.clear()
        location_input.send_keys(location)
        location_input.submit()

        # Apply Easy Apply filter
        self.wait.until(EC.element_to_be_clickable(
            (By.XPATH, "//button[contains(@aria-label, 'Easy Apply filter')]")
        )).click()
        time.sleep(2)

    def apply_to_job(self):
        jobs = self.driver.find_elements(
            By.CSS_SELECTOR, "div.job-card-container--clickable")

        if not jobs:
            return False

        for job in jobs:
            if "Applied" not in job.text:
                job.click()
                time.sleep(2)
                return True
        return False

    def handle_application(self):
        start_time = time.time()
        try:
            # Click Easy Apply
            apply_button = self.wait.until(EC.element_to_be_clickable(
                (By.CSS_SELECTOR, "button.jobs-apply-button")
            ))
            apply_button.click()
            time.sleep(1)

            # Process application form
            self.process_form()

            # Submit application
            submit_button = self.wait.until(EC.element_to_be_clickable(
                (By.CSS_SELECTOR, "button[aria-label='Submit application']")
            ))
            submit_button.click()
            time.sleep(1)

            # Record metrics
            submit_time = time.time()
            duration = submit_time - start_time

            return {
                "start_time": time.strftime("%H:%M:%S", time.localtime(start_time)),
                "submit_time": time.strftime("%H:%M:%S", time.localtime(submit_time)),
                "duration": round(duration, 2),
                "questions_asked": "\n".join([q for q, _ in self.qa_pairs]),
                "questions_answered": "\n".join([a for _, a in self.qa_pairs])
            }

        except Exception as e:
            print(f"Application error: {str(e)}")
            return None
        finally:
            try:
                self.driver.find_element(
                    By.CSS_SELECTOR, "button[aria-label='Dismiss']").click()
                time.sleep(1)
            except:
                pass

    def process_form(self):
        self.qa_pairs = []
        page_num = 1

        while True:
            # Process current page
            self.process_form_page()

            # Check for next page or submit
            next_buttons = self.driver.find_elements(
                By.XPATH, "//button[contains(@aria-label, 'Continue to next')]")
            submit_buttons = self.driver.find_elements(
                By.XPATH, "//button[contains(@aria-label, 'Submit application')]"
            )

            if submit_buttons:
                break
            elif next_buttons:
                next_buttons[0].click()
                time.sleep(1.5)
                page_num += 1
            else:
                break

    def process_form_page(self):
        # Get all form fields
        fields = self.driver.find_elements(
            By.CSS_SELECTOR, ".jobs-easy-apply-form-section__grouping"
        )

        for field in fields:
            try:
                question = field.find_element(By.TAG_NAME, "label").text
                answer = self.generate_answer(question)

                # Find appropriate input field
                input_field = field.find_element(By.TAG_NAME, "input")
                input_field.clear()
                input_field.send_keys(answer)

                self.qa_pairs.append((question, answer))

            except NoSuchElementException:
                continue

    def generate_answer(self, question):
        # Layer 1: Check resume keywords
        for keyword in RULE_BASED_DATA:
            if keyword.lower() in question.lower():
                return RULE_BASED_DATA[keyword]

        # Layer 2: Check rule-based fallbacks
        if "authorized" in question.lower() or "work permit" in question.lower():
            return "Yes"
        if "sponsor" in question.lower():
            return "No"
        if "notice" in question.lower():
            return RULE_BASED_DATA["notice_period"] + " days"
        if "salary" in question.lower() and "expect" in question.lower():
            return RULE_BASED_DATA["expected_ctc"]
        if "experience" in question.lower():
            return RULE_BASED_DATA["experience"] + " years"
        if "phone" in question.lower() or "contact" in question.lower():
            return RULE_BASED_DATA["phone"]
        if "name" in question.lower():
            return RULE_BASED_DATA["name"]

        # Layer 3: Use AI
        return self.generate_ai_answer(question)

    def generate_ai_answer(self, question):
        genai.configure(api_key=GEMINI_API_KEY)
        model = genai.GenerativeModel('gemini-2.0-flash')

        prompt = f"""
        Based on the resume information and candidate details,
        provide a concise, professional answer to the job application question.
        Keep responses under 20 words.

        Resume Summary:
        {self.resume_text[:2000]}

        Candidate Details:
        {RULE_BASED_DATA}

        Application Question:
        "{question}"
        """

        try:
            response = model.generate_content(prompt)
            return response.text.strip()
        except Exception as e:
            print(f"AI Error: {str(e)}")
            return "Available upon request"

    def cleanup(self):
        """Clean up resources and delete temporary directory"""
        try:
            self.driver.quit()
        except:
            pass
        try:
            shutil.rmtree(self.user_data_dir, ignore_errors=True)
        except:
            pass

# ===== Worker Thread =====
def process_applications(app):
    while True:
        job_data = application_data_queue.get()
        automator = None
        try:
            # Parse resume
            resume_text = parse_resume(job_data['resume_path'])

            # Initialize automator
            automator = LinkedInAutomator()
            automator.resume_text = resume_text
            automator.login()
            automator.search_jobs(job_data['job_role'], job_data['location'])

            # Track successful applications
            success_count = 0

            for _ in range(job_data['num_applications']):
                if automator.apply_to_job():
                    result = automator.handle_application()
                    if result:
                        try:
                            company = automator.driver.find_element(
                                By.CSS_SELECTOR, "a.jobs-unified-top-card__company-name"
                            ).text.strip()
                        except:
                            company = "Unknown"

                        # Prepare Google Sheets data
                        sheet_data = {
                            'date': time.strftime("%Y-%m-%d"),
                            'job_role': job_data['job_role'],
                            'company': company,
                            'start_time': result['start_time'],
                            'submit_time': result['submit_time'],
                            'duration': result['duration'],
                            'questions_asked': result['questions_asked'],
                            'questions_answered': result['questions_answered']
                        }

                        # Log to Google Sheets
                        log_to_google_sheets(sheet_data)
                        success_count += 1

            # Send completion message using main thread's event loop
            completion_msg = (
                f"✅ Successfully submitted {job_data['job_role']} "
                f"applications {success_count} times in {job_data['location']}."
            )
            asyncio.run_coroutine_threadsafe(
                app.bot.send_message(job_data['chat_id'], completion_msg),
                app.bot.loop
            )

        except Exception as e:
            error_msg = f"⚠️ Processing error: {str(e)}"
            asyncio.run_coroutine_threadsafe(
                app.bot.send_message(job_data['chat_id'], error_msg),
                app.bot.loop
            )
        finally:
            try:
                if automator:
                    automator.cleanup()
            except Exception as e:
                print(f"Cleanup error: {str(e)}")
            try:
                os.remove(job_data['resume_path'])
            except:
                pass
            application_data_queue.task_done()

# ===== Bot Runner =====
def run_bot():
    """Run the Telegram bot"""
    app = Application.builder().token(TELEGRAM_TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            JOB_ROLE: [MessageHandler(filters.TEXT & ~filters.COMMAND, job_role)],
            NUM_APPLICATIONS: [MessageHandler(filters.TEXT & ~filters.COMMAND, num_applications)],
            LOCATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, location)],
            RESUME: [MessageHandler(filters.Document.PDF, resume)],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )

    app.add_handler(conv_handler)

    # Start worker thread with app reference
    worker_thread = threading.Thread(
        target=process_applications,
        args=(app,),
        daemon=True
    )
    worker_thread.start()

    print("Bot is running and waiting for your messages...")
    app.run_polling()

# ===== Main Execution =====
if __name__ == "__main__":
    run_bot()